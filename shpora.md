1. базовое понятие алгоритма  
алгоритм — конечная последовательность однозначных инструкций для решения задачи  
свойства: дискретность, детерминированность, конечность, массовость, результативность  
вычислительная сложность отражает количество элементарных операций, необходимых для выполнения алгоритма  
описательная сложность — это длина текста или кода, описывающего алгоритм  
главный параметр сложности — размер входных данных, обычно обозначаемый как n

2. математические основы данных  
системы счисления: двоичная (основание 2), десятичная (10), шестнадцатеричная (16)  
преобразования между системами выполняются через деление на основание или группировку битов  
проверка корректности записи числа: каждая цифра должна быть строго меньше основания системы  
побитовые операции работают на уровне отдельных битов  
and возвращает 1 только если оба бита равны 1  
or возвращает 1, если хотя бы один бит равен 1  
xor возвращает 1, если биты различны  
not инвертирует каждый бит  
применяются для работы с флагами, масками, шифрованием и оптимизациями

3. представление чисел  
числа с плавающей запятой хранятся в формате ieee 754, который включает знак, экспоненту и мантиссу  
этот формат позволяет представлять очень большие и очень маленькие числа, но с ограниченной точностью  
машинная точность ε — это наименьшее положительное число, такое что 1 + ε ≠ 1 в арифметике компьютера  
обычно ε ≈ 2⁻⁵² для double в ieee 754  
быстрое возведение в степень использует рекурсивное разложение: aⁿ = (aⁿ/²)² при чётном n и a·aⁿ⁻¹ при нечётном  
сложность этого метода — O(log n)  
алгоритм евклида находит наибольший общий делитель двух чисел с помощью последовательного взятия остатка  
его время работы пропорционально логарифму меньшего из чисел  
перевод в римские числа осуществляется заменой арабских цифр на соответствующие символы по убыванию значений

4. типы данных и операции  
элементарные типы: целые, вещественные, логические, символьные  
производные типы включают массивы, структуры, перечисления и указатели  
массив — упорядоченный набор элементов одного типа с доступом по индексу  
базовые операции: линейный поиск, нахождение минимума и максимума, вычисление префиксных сумм  
префиксные суммы позволяют быстро находить сумму на любом подотрезке за O(1) после O(n) предподсчёта  
динамический массив автоматически увеличивает свой размер при добавлении новых элементов, обычно вдвое

5. комплексные числа  
алгебраическая форма записи: a + bi, где i² = −1  
показательная форма: r·e^(iφ), где r — модуль, φ — аргумент (угол)  
арифметические операции: сложение и вычитание покомпонентны, умножение и деление удобнее в показательной форме  
модуль комплексного числа |z| = √(a² + b²)  
сортировка комплексных чисел возможна по модулю или по аргументу, в зависимости от задачи

6. асимптотический анализ  
асимптотические обозначения описывают поведение функций при стремлении аргумента к бесконечности  
O(f(n)) задаёт верхнюю границу: T(n) ≤ c·f(n) для достаточно больших n  
Ω(f(n)) — нижняя граница: T(n) ≥ c·f(n)  
Θ(f(n)) означает, что функция ограничена сверху и снизу одним порядком роста  
сравнение скоростей роста: константы < логарифмы < линейные < n log n < квадратичные < экспоненциальные  
ram-модель (random access machine) предполагает, что любая базовая операция (чтение, запись, арифметика) выполняется за единичное время  
эта модель используется для теоретического анализа алгоритмов без учёта особенностей реального железа

7. амортизационный анализ  
амортизационный анализ оценивает среднюю стоимость операции в последовательности, даже если отдельные операции могут быть дорогими  
метод агрегирования: общая стоимость всех операций делится на их количество  
метод предоплаты (или бухгалтерский): каждой операции назначается «платёж», часть которого может откладываться как кредит для будущих дорогих операций  
метод потенциалов: вводится функция потенциала Φ, и амортизированная стоимость = реальная стоимость + изменение потенциала  
пример — динамический массив: при переполнении происходит копирование, но амортизированная стоимость push остаётся O(1)  
очередь на двух стеках: enqueue — в один стек, dequeue — из другого; при опустошении второго стека перекидываем всё из первого, что даёт амортизированное O(1)

8. квадратичные сортировки  
пузырьковая сортировка многократно проходит по массиву, меняя соседние элементы, если они стоят в неправильном порядке  
сортировка выбором находит минимальный элемент и ставит его в начало, затем повторяет для оставшейся части  
сортировка вставками поочерёдно вставляет элементы в уже отсортированную часть массива  
все три имеют временную сложность O(n²) в худшем случае  
однако сортировка вставками эффективна на почти отсортированных данных и имеет O(n) в лучшем случае

9. рекурсивные сортировки  
сортировка слиянием делит массив пополам, рекурсивно сортирует части и сливает их в отсортированный массив  
она устойчива, то есть не меняет порядок равных элементов, и всегда работает за O(n log n)  
сортировка подсчётом применима только к целым числам из ограниченного диапазона [0, k]  
она создаёт массив счётчиков, затем восстанавливает порядок элементов  
её сложность — O(n + k), что линейно при малом k

10. быстрая сортировка (quicksort)  
алгоритм выбирает опорный элемент (pivot), разделяет массив на элементы меньше и не меньше pivot, затем рекурсивно сортирует обе части  
в среднем случае, при случайном выборе pivot, сложность составляет O(n log n)  
в худшем случае (например, когда pivot всегда минимальный или максимальный) сложность деградирует до O(n²)  
на практике quicksort часто быстрее других сортировок благодаря хорошей локальности данных и низкой константе

11. теоретические пределы сортировок  
для любого алгоритма сортировки, основанного только на сравнениях, существует нижняя граница Ω(n log n)  
это следует из того, что дерево решений должно иметь не менее n! листьев, а его высота не меньше log₂(n!)  
таким образом, merge sort и heap sort асимптотически оптимальны среди comparison-based алгоритмов

12. рекурсия  
рекурсивная функция вызывает саму себя с изменёнными аргументами  
обязательные условия корректной рекурсии: наличие базового случая и продвижение к нему на каждом шаге  
стек вызовов хранит контекст каждого активного вызова, включая локальные переменные и адрес возврата  
классические примеры: вычисление факториала, чисел фибоначчи, решение задачи о ханойских башнях  
мемоизация — техника кэширования результатов подзадач для избежания повторных вычислений, особенно полезна в динамическом программировании

13. рекуррентные соотношения и мастер-теорема  
многие рекурсивные алгоритмы описываются рекуррентой вида T(n) = aT(n/b) + f(n), где a ≥ 1, b > 1  
мастер-теорема даёт готовые условия для определения асимптотики таких рекуррент  
случай 1: если f(n) растёт медленнее n^(log_b a) на полиномиальный множитель, то T(n) = Θ(n^(log_b a))  
случай 2: если f(n) = Θ(n^(log_b a) · logᵏ n), то T(n) = Θ(n^(log_b a) · logᵏ⁺¹ n); чаще всего k = 0  
случай 3: если f(n) растёт быстрее n^(log_b a) и удовлетворяет условию регулярности, то T(n) = Θ(f(n))  
пример: для сортировки слиянием a = 2, b = 2, f(n) = n → log_b a = 1, f(n) = Θ(n), значит T(n) = Θ(n log n)

14. линейные структуры данных  
односвязный список состоит из узлов, каждый из которых содержит данные и указатель на следующий узел  
двусвязный список дополнительно хранит указатель на предыдущий узел, что позволяет двигаться в обе стороны  
основные операции: вставка и удаление за O(1), если известен узел, и за O(n) при поиске по значению  
списки гибче массивов по памяти, но хуже по локальности и произвольному доступу

15. стек  
стек — структура данных с принципом lifo (последним пришёл — первым ушёл)  
основные операции: push (добавить наверх), pop (удалить верхний), peek (посмотреть верхний без удаления)  
реализуется на массиве (с указателем на вершину) или на связном списке  
часто используется для проверки корректности скобочных последовательностей, вычисления выражений в обратной польской записи  
для поддержки операции поиска минимума можно хранить пары (значение, текущий минимум) или использовать дополнительный стек минимумов

16. очередь  
очередь работает по принципу fifo (первым пришёл — первым ушёл)  
операции: enqueue (добавить в конец), dequeue (извлечь из начала)  
циклический буфер — эффективная реализация на массиве с двумя указателями (head и tail), которые «заворачиваются» в начало при достижении конца  
альтернатива — реализация на двух стеках, где первый стек используется для enqueue, второй — для dequeue, с переносом при опустошении второго

17. куча (бинарная)  
бинарная куча — полное бинарное дерево, в котором выполняется свойство кучи: значение родителя не больше (min-heap) или не меньше (max-heap) значений детей  
хранится в массиве: для элемента с индексом i дети находятся на позициях 2i+1 и 2i+2, родитель — на (i−1)//2  
просеивание вверх (sift-up) используется после вставки, чтобы восстановить порядок  
просеивание вниз (sift-down) — после извлечения корня

18. операции на куче и её применения  
вставка: добавляем в конец массива и просеиваем вверх  
извлечение экстремума: меняем корень с последним элементом, удаляем последний, просеиваем новый корень вниз  
построение кучи из массива за O(n) возможно с помощью просеивания вниз для всех внутренних узлов снизу вверх  
куча лежит в основе очереди с приоритетом и алгоритма пирамидальной сортировки (heapsort)  
heapsort строит max-heap, затем последовательно извлекает максимум и помещает его в конец массива

19. более сложные структуры на основе кучи  
поиск k-го наименьшего элемента: можно использовать max-heap размера k, сохраняя в нём k самых маленьких элементов  
слияние k отсортированных массивов: в min-heap кладутся первые элементы всех массивов, затем извлекается минимум и добавляется следующий элемент из того же массива  
биномиальные кучи — более сложная структура, поддерживающая эффективное слияние за O(log n), но редко используются на практике

20. теория графов: основы  
граф состоит из множества вершин и рёбер между ними  
может быть ориентированным (рёбра имеют направление) или неориентированным  
степень вершины — число рёбер, инцидентных ей; в орграфе различают входящую и исходящую степени  
лемма о рукопожатиях утверждает, что сумма степеней всех вершин равна удвоенному числу рёбер  
граф можно хранить в виде матрицы смежности (удобно для плотных графов) или списков смежности (эффективно для разреженных)

21. связность в графах  
компоненты связности — максимальные подграфы, в которых любые две вершины соединены путём  
в ориентированных графах различают слабую и сильную связность  
мост — ребро, удаление которого увеличивает число компонент связности  
точка сочленения — вершина, удаление которой нарушает связность  
алгоритмы поиска мостов и точек сочленения основаны на dfs с отслеживанием времени входа и low-link значений

22. деревья  
дерево — связный ациклический неориентированный граф  
эквивалентные определения: n вершин и n−1 ребро, единственный простой путь между любой парой вершин, связный и без циклов  
остовное дерево графа — подграф, содержащий все вершины и являющийся деревом  
взвешенные графы могут иметь минимальное остовное дерево (mst), строящееся алгоритмами кrusкала или прима

23. эйлеровы пути и циклы  
эйлеров цикл проходит по каждому ребру ровно один раз и заканчивается в начальной вершине  
эйлеров путь делает то же самое, но начинается и заканчивается в разных вершинах  
в неориентированном графе эйлеров цикл существует тогда и только тогда, когда граф связен и все степени чётны  
эйлеров путь существует, если граф связен и ровно две вершины имеют нечётную степень  
алгоритм hierholzer строит такой путь за линейное время, последовательно удаляя использованные рёбра

24. обход графов: bfs  
поиск в ширину использует очередь для обхода вершин по уровням от начальной  
гарантированно находит кратчайший путь в невзвешенном графе  
алгоритм помечает расстояния от стартовой вершины и предшественников для восстановления пути  
временная сложность — O(n + m), где n — число вершин, m — число рёбер

25. обход графов: dfs  
поиск в глубину исследует граф, углубляясь в одну ветвь до упора, затем возвращаясь назад  
реализуется рекурсивно или с явным стеком  
применяется для поиска компонент связности, обнаружения циклов, топологической сортировки и поиска сильно связных компонент  
топологическая сортировка возможна только в dag (ориентированном ациклическом графе) и строится по убыванию времени выхода из вершин в dfs
